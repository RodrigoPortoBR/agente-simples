"""
Orchestrator Agent - REFATORADO PARA DADOS DE NEG√ìCIO
CAMADA 1: Interface √∫nica com o usu√°rio - FOCO EM AN√ÅLISE DE DADOS
"""
import openai
import json
from typing import Dict, Any, List, Optional
from datetime import datetime

from models import (
    OrchestratorResponse, 
    AgentInstruction, 
    AgentType, 
    MessageRole,
    IntentAnalysis,
    IntentType,
    SQLQueryRequest
)
from config import settings
from services.memory_service import MemoryService
from agents.sql_agent import SQLAgent

class OrchestratorAgent:
    """
    Agente Orquestrador - Especialista em An√°lise de Dados de E-commerce
    
    RESPONSABILIDADES:
    - Conversar com usu√°rio sobre dados de neg√≥cio
    - Identificar quando precisa consultar banco de dados
    - Delegar an√°lises ao SQL Agent
    - Converter resultados JSON em linguagem natural
    - N√ÉO analisar conversas - FOCAR EM DADOS DE CLIENTES
    """
    
    def __init__(self):
        self.client = openai.OpenAI(api_key=settings.OPENAI_API_KEY)
        self.memory = MemoryService()
        self.sql_agent = SQLAgent()
        
        # System prompt FOCADO EM DADOS DE NEG√ìCIO
        self.system_prompt = """Voc√™ √© um Analista de Dados de E-commerce especializado.

SUA FUN√á√ÉO:
- Analisar dados de CLIENTES, RECEITA, MARGEM e CLUSTERS
- Responder perguntas sobre NEG√ìCIO e PERFORMANCE
- Fornecer INSIGHTS acion√°veis baseados em dados

DADOS DISPON√çVEIS (Lovable Cloud - Supabase):

üìä CLIENTES (tabela: clientes)
- CPF, cluster, pedidos_12m, recencia_dias
- receita_bruta_12m, receita_liquida_12m
- qtde_produtos, cmv_12m, desconto
- gm_12m (margem bruta), gm_pct_12m
- mcc (margem contribui√ß√£o), mcc_pct
- despesas

üéØ CLUSTERS (tabela: clusters)
- id, label (nome do cluster)
- gm_total, gm_pct_medio
- clientes (quantidade), freq_media, recencia_media
- gm_cv (volatilidade), tendencia

üìà S√âRIES TEMPORAIS (tabela: monthly_series)
- month (YYYY-MM)
- receita_bruta, receita_liquida, cmv, margem_bruta
- clusters (dados JSON por m√™s)

üõí PEDIDOS (tabela: pedidos)
- pedido_id, cliente_id, data
- receita_bruta, margem_bruta, categoria

CLUSTERS EXISTENTES:
1. Premium - Clientes top de receita
2. Alto Valor - Bom faturamento
3. M√©dio - Performance regular
4. Baixo - Menor faturamento
5. Novos - Clientes recentes

REGRAS:
- Sempre que usu√°rio perguntar sobre N√öMEROS, DADOS, M√âTRICAS ‚Üí buscar no banco
- Conversa geral ‚Üí responder diretamente
- Usar dados reais para dar insights
- Focar em a√ß√µes pr√°ticas

ESTILO:
- Objetivo e direto
- M√°ximo 200 palavras
- Use emojis estrategicamente (üìä üí∞ üìà üéØ üí°)
- Destaque n√∫meros importantes
- Portugu√™s brasileiro"""
    
    async def process_user_message(
        self, 
        user_message: str, 
        session_id: str
    ) -> OrchestratorResponse:
        """
        Processa mensagem do usu√°rio (m√©todo principal)
        
        Args:
            user_message: Mensagem do usu√°rio
            session_id: ID da sess√£o
        
        Returns:
            OrchestratorResponse com resposta final
        """
        try:
            processing_steps = []
            agents_used = [AgentType.ORCHESTRATOR]
            
            # 1. Salvar mensagem do usu√°rio na mem√≥ria
            await self.memory.add_message(
                session_id=session_id,
                role=MessageRole.USER,
                content=user_message
            )
            processing_steps.append("üíæ Mensagem salva")
            
            # 2. Recuperar contexto recente (√∫ltimas mensagens)
            context_messages = await self.memory.get_recent_context(
                session_id=session_id,
                num_messages=6  # Reduzido para economizar tokens
            )
            processing_steps.append(f"üìö Contexto: {len(context_messages)} msgs")
            
            # 3. Analisar inten√ß√£o - FOCO EM DADOS DE NEG√ìCIO
            intent = await self._analyze_business_intent(user_message, context_messages)
            processing_steps.append(f"üîç Inten√ß√£o: {intent.intent_type.value}")
            
            # 4. Processar baseado na inten√ß√£o
            if intent.needs_data_analysis and intent.requires_agent == AgentType.SQL:
                # Consultar dados de neg√≥cio no banco
                response_text = await self._handle_business_data_request(
                    user_message=user_message,
                    intent=intent,
                    session_id=session_id,
                    processing_steps=processing_steps
                )
                agents_used.append(AgentType.SQL)
            else:
                # Conversa geral sobre neg√≥cio
                response_text = await self._handle_business_chat(
                    user_message=user_message,
                    context_messages=context_messages
                )
                processing_steps.append("üí¨ Chat de neg√≥cio")
            
            # 5. Salvar resposta
            await self.memory.add_message(
                session_id=session_id,
                role=MessageRole.ASSISTANT,
                content=response_text,
                metadata={
                    "agents_used": [a.value for a in agents_used],
                    "intent_type": intent.intent_type.value
                }
            )
            processing_steps.append("üíæ Resposta salva")
            
            return OrchestratorResponse(
                response=response_text,
                session_id=session_id,
                timestamp=datetime.now(),
                success=True,
                agents_used=agents_used,
                processing_steps=processing_steps,
                metadata={
                    "intent_confidence": intent.confidence,
                    "intent_type": intent.intent_type.value
                }
            )
            
        except Exception as e:
            print(f"‚ùå Erro no Orchestrator: {e}")
            
            error_message = (
                "Desculpe, encontrei um problema ao processar sua solicita√ß√£o. "
                "Pode reformular sua pergunta sobre os dados? ü§î"
            )
            
            await self.memory.add_message(
                session_id=session_id,
                role=MessageRole.ASSISTANT,
                content=error_message,
                metadata={"error": str(e)}
            )
            
            return OrchestratorResponse(
                response=error_message,
                session_id=session_id,
                timestamp=datetime.now(),
                success=False,
                agents_used=[AgentType.ERROR],
                processing_steps=[f"‚ùå Erro: {str(e)}"]
            )
    
    async def _analyze_business_intent(
        self,
        user_message: str,
        context_messages: List[Dict[str, str]]
    ) -> IntentAnalysis:
        """
        Analisa inten√ß√£o do usu√°rio - FOCO EM DADOS DE NEG√ìCIO
        
        Args:
            user_message: Mensagem atual do usu√°rio
            context_messages: Mensagens recentes
        
        Returns:
            IntentAnalysis com decis√£o estruturada
        """
        try:
            # Construir contexto recente
            conversation_context = ""
            if context_messages:
                recent = context_messages[-3:]  # √öltimas 3 mensagens
                for msg in recent:
                    conversation_context += f"{msg['role']}: {msg['content']}\n"
            
            prompt = f"""Analise a pergunta do usu√°rio e determine se precisa CONSULTAR DADOS DO BANCO.

CONTEXTO RECENTE:
{conversation_context}

PERGUNTA DO USU√ÅRIO: "{user_message}"

DADOS DISPON√çVEIS NO BANCO (Lovable Cloud):
‚Ä¢ clientes: receita_bruta_12m, gm_12m, mcc, cluster, pedidos_12m, recencia_dias, etc
‚Ä¢ clusters: label, gm_total, gm_pct_medio, clientes, freq_media, tendencia
‚Ä¢ monthly_series: receita_bruta, margem_bruta por m√™s
‚Ä¢ pedidos: pedido_id, cliente_id, receita_bruta, margem_bruta, categoria

CLUSTERS:
1=Premium, 2=Alto, 3=M√©dio, 4=Baixo, 5=Novos

EXEMPLOS DE AN√ÅLISE:

‚úÖ PRECISA CONSULTAR BANCO (data_analysis):
- "Qual a receita do cluster premium?" ‚Üí SELECT SUM(receita_bruta_12m) FROM clientes WHERE cluster=1
- "Quantos clientes temos?" ‚Üí SELECT COUNT(*) FROM clientes
- "Top 10 clientes por margem" ‚Üí SELECT * FROM clientes ORDER BY gm_12m DESC LIMIT 10
- "Receita do √∫ltimo m√™s" ‚Üí SELECT receita_bruta FROM monthly_series ORDER BY month DESC LIMIT 1
- "Clientes do cluster 2" ‚Üí SELECT * FROM clientes WHERE cluster=2

‚ùå N√ÉO PRECISA BANCO (general_chat):
- "Ol√°" / "Oi" / "Tudo bem?"
- "O que voc√™ pode fazer?"
- "Explica o que √© cluster"
- "Como funciona a margem?"
- "O que significa MCC?"

RESPONDA EM JSON:
{{
  "intent_type": "data_analysis" | "general_chat",
  "confidence": 0.0-1.0,
  "needs_data_analysis": true/false,
  "requires_agent": "sql_agent" | null,
  "extracted_parameters": {{
    "query_type": "aggregate" | "count" | "select" | "filter",
    "table": "clientes" | "clusters" | "pedidos" | "monthly_series",
    "filters": {{"cluster": 1}},
    "fields": ["receita_bruta_12m", "gm_12m"],
    "aggregation": {{"receita_bruta_12m": "sum"}},
    "order_by": "receita_bruta_12m.desc",
    "limit": 10
  }},
  "reasoning": "Breve explica√ß√£o"
}}

REGRAS:
- Se pergunta sobre N√öMEROS, DADOS, M√âTRICAS ‚Üí data_analysis
- Se sauda√ß√£o, explica√ß√£o conceitual ‚Üí general_chat
- Extraia filtros: cluster, per√≠odo, categoria
- Identifique campos necess√°rios
- Defina tipo de agrega√ß√£o (sum, avg, count, max, min)"""

            response = self.client.chat.completions.create(
                model=settings.OPENAI_MODEL,
                messages=[{"role": "user", "content": prompt}],
                max_tokens=500,
                temperature=0.2
            )
            
            llm_response = response.choices[0].message.content
            
            # Extrair JSON
            json_start = llm_response.find('{')
            json_end = llm_response.rfind('}') + 1
            json_str = llm_response[json_start:json_end]
            intent_data = json.loads(json_str)
            
            return IntentAnalysis(
                intent_type=IntentType(intent_data.get("intent_type", "general_chat")),
                confidence=intent_data.get("confidence", 0.7),
                needs_data_analysis=intent_data.get("needs_data_analysis", False),
                requires_agent=(
                    AgentType.SQL if intent_data.get("requires_agent") == "sql_agent" 
                    else None
                ),
                extracted_parameters=intent_data.get("extracted_parameters", {}),
                reasoning=intent_data.get("reasoning", "")
            )
            
        except Exception as e:
            print(f"‚ö†Ô∏è Erro na an√°lise, usando fallback: {e}")
            
            # Fallback: an√°lise por keywords de NEG√ìCIO
            message_lower = user_message.lower()
            business_keywords = [
                'receita', 'margem', 'cliente', 'cluster', 'vendas',
                'faturamento', 'lucro', 'mcc', 'pedido', 'quanto',
                'quantos', 'total', 'm√©dia', 'top', 'melhor', 'pior',
                'crescimento', 'tend√™ncia', 'performance', 'dados'
            ]
            
            needs_data = any(keyword in message_lower for keyword in business_keywords)
            
            # Construir par√¢metros b√°sicos para o fallback
            extracted_params = {}
            
            if needs_data:
                # Detectar tipo de query
                if any(w in message_lower for w in ['quantos', 'quantidade', 'numero', 'count']):
                    query_type = 'count'
                elif any(w in message_lower for w in ['total', 'soma', 'receita', 'margem', 'media']):
                    query_type = 'aggregate'
                elif any(w in message_lower for w in ['top', 'melhor', 'pior', 'lista']):
                    query_type = 'select'
                else:
                    query_type = 'select'
                
                # Detectar tabela
                if 'cluster' in message_lower:
                    table = 'clusters'
                elif any(w in message_lower for w in ['pedido', 'compra', 'transacao']):
                    table = 'pedidos'
                elif any(w in message_lower for w in ['mes', 'mensal', 'serie', 'temporal']):
                    table = 'monthly_series'
                else:
                    table = 'clientes'
                
                # Construir par√¢metros
                extracted_params = {
                    'query_type': query_type,
                    'table': table,
                    'filters': {},
                    'fields': [],
                    'aggregation': {},
                    'order_by': None,
                    'limit': 10
                }
                
                # Agrega√ß√£o comum
                if query_type == 'aggregate':
                    if 'receita' in message_lower:
                        extracted_params['aggregation'] = {'receita_bruta_12m': 'sum'}
                        extracted_params['fields'] = ['receita_bruta_12m']
                    elif 'margem' in message_lower:
                        extracted_params['aggregation'] = {'gm_12m': 'sum'}
                        extracted_params['fields'] = ['gm_12m']
                    elif 'mcc' in message_lower:
                        extracted_params['aggregation'] = {'mcc': 'sum'}
                        extracted_params['fields'] = ['mcc']
            
            return IntentAnalysis(
                intent_type=IntentType.DATA_ANALYSIS if needs_data else IntentType.GENERAL_CHAT,
                confidence=0.6,
                needs_data_analysis=needs_data,
                requires_agent=AgentType.SQL if needs_data else None,
                extracted_parameters=extracted_params,
                reasoning="Fallback: an√°lise por keywords de neg√≥cio"
            )
    
    async def _handle_business_data_request(
        self,
        user_message: str,
        intent: IntentAnalysis,
        session_id: str,
        processing_steps: List[str]
    ) -> str:
        """
        Processa requisi√ß√£o de DADOS DE NEG√ìCIO
        
        Args:
            user_message: Pergunta do usu√°rio
            intent: An√°lise de inten√ß√£o
            session_id: ID da sess√£o
            processing_steps: Lista de passos
        
        Returns:
            Resposta em linguagem natural
        """
        try:
            # Criar instru√ß√£o estruturada para SQL Agent
            sql_instruction = AgentInstruction(
                agent_type=AgentType.SQL,
                task_description=f"Consultar dados de neg√≥cio: {user_message}",
                parameters=intent.extracted_parameters,
                context={
                    "user_question": user_message,
                    "intent_reasoning": intent.reasoning
                },
                session_id=session_id
            )
            
            processing_steps.append("üì§ Consultando banco de dados")
            
            # Delegar para SQL Agent
            sql_response = await self.sql_agent.process_instruction(sql_instruction)
            
            if sql_response.success:
                processing_steps.append(
                    f"‚úÖ Dados obtidos ({sql_response.metadata.get('row_count', 0)} registros)"
                )
                
                # Converter JSON em linguagem natural COM FOCO EM NEG√ìCIO
                natural_response = await self._convert_business_data_to_natural(
                    user_question=user_message,
                    data=sql_response.data,
                    metadata=sql_response.metadata
                )
                
                processing_steps.append("üó£Ô∏è Resposta formatada")
                
                return natural_response
            else:
                processing_steps.append(f"‚ùå Erro: {sql_response.error}")
                
                return (
                    f"N√£o consegui obter os dados solicitados. "
                    f"Pode reformular sua pergunta sobre clientes, receita ou clusters? üòï"
                )
                
        except Exception as e:
            processing_steps.append(f"‚ùå Erro: {str(e)}")
            
            return (
                "Desculpe, encontrei um problema ao buscar os dados. "
                "Pode tentar perguntar de outra forma? ü§î"
            )
    
    async def _convert_business_data_to_natural(
        self,
        user_question: str,
        data: Optional[Dict[str, Any]],
        metadata: Dict[str, Any]
    ) -> str:
        """
        Converte dados de NEG√ìCIO em linguagem natural com INSIGHTS PROFUNDOS
        
        Args:
            user_question: Pergunta original
            data: Dados retornados
            metadata: Metadados da query
        
        Returns:
            Resposta formatada com an√°lise profunda
        """
        try:
            data_context = json.dumps(data, indent=2, ensure_ascii=False) if data else "{}"
            
            prompt = f"""Voc√™ √© um Analista de Dados S√™nior com 10+ anos de experi√™ncia em e-commerce.

PERGUNTA DO USU√ÅRIO: "{user_question}"

DADOS OBTIDOS:
{data_context}

METADADOS:
- Registros: {metadata.get('row_count', 0)}
- Tempo: {metadata.get('execution_time', 0):.2f}s
- Tabela consultada: {metadata.get('query_info', {}).get('table', 'N/A')}
- Filtros aplicados: {metadata.get('query_info', {}).get('filtros', {})}

CONTEXTO DE NEG√ìCIO:
‚Ä¢ Clusters: 1=Ouro (top), 2=Top-line baixo GM, 3=Vol√°til, 4=Latente, 5=Novos
‚Ä¢ Margem saud√°vel: 40-50% (este neg√≥cio espec√≠fico)
‚Ä¢ MCC = Margem de Contribui√ß√£o (receita l√≠quida - CMV - despesas)
‚Ä¢ Rec√™ncia baixa = cliente ativo recente
‚Ä¢ Frequ√™ncia alta = cliente fiel e recorrente

AN√ÅLISE PROFUNDA REQUERIDA:

1. üìä N√öMEROS PRINCIPAIS
   - Destaque o valor principal da pergunta
   - Contextualize com %  do total se relevante
   - Compare com benchmarks do setor

2. üîç AN√ÅLISE APROFUNDADA (OBRIGAT√ìRIO - n√£o seja superficial!)
   - O que esse n√∫mero revela sobre o comportamento dos clientes?
   - Quais padr√µes ou anomalias voc√™ identifica?
   - Como isso se relaciona com a sa√∫de do neg√≥cio?
   - H√° concentra√ß√£o de risco ou oportunidade?
   
3. üí° INSIGHTS ESTRAT√âGICOS (seja espec√≠fico!)
   - Identifique 2-3 insights CONCRETOS desses dados
   - N√£o seja √≥bvio ("manter clientes engajados")
   - Seja espec√≠fico sobre O QUE fazer e COMO
   - Use dados para embasar cada insight
   
4. üéØ PLANO DE A√á√ÉO (detalhado!)
   - N√ÉO diga apenas "criar programa VIP"
   - DIGA: "Implementar programa de cashback de 3% para compras acima de R$500, focado nos top 20 clientes que respondem por 60% da receita"
   - Priorize a√ß√µes por impacto/esfor√ßo
   - Seja tang√≠vel e implement√°vel HOJE

5. ‚ö†Ô∏è ALERTAS E RISCOS (se aplic√°vel)
   - Identifique riscos escondidos nos dados
   - Destaque depend√™ncias problem√°ticas
   - Sinalize tend√™ncias preocupantes

FORMATO DA RESPOSTA:
- M√°ximo 300 palavras
- Use emojis com modera√ß√£o (üìä üí∞ üìà üéØ üí° ‚ö†Ô∏è)
- Seja DIRETO e ACION√ÅVEL
- Evite frases vagas como "√© importante", "pode ser interessante"
- Use n√∫meros e % sempre que poss√≠vel
- Priorize PROFUNDIDADE sobre EXTENS√ÉO

EXEMPLO DE AN√ÅLISE PROFUNDA:
"üìä O Cluster 3 (Vol√°til) gerou **R$ 258.727** em receita nos √∫ltimos 12 meses, com 139 clientes (margem m√©dia: 47%).

üîç **An√°lise:** Esse cluster tem a MELHOR margem (47% vs 44% dos outros), mas volume menor. Cada cliente gera R$ 1.860 em m√©dia - 2,3x mais rent√°vel que o Cluster 4. A volatilidade vem de compras espa√ßadas (rec√™ncia m√©dia: 90 dias) mas tickets altos.

üí° **Insights:**
1. **Potencial inexplorado**: Se aumentarmos frequ√™ncia de apenas 10 clientes top desse cluster para compras mensais, ganhar√≠amos +R$ 22k/ano
2. **Margem superior**: Produtos comprados t√™m melhor mix - vale mapear categorias e replicar estrat√©gia
3. **Risco de churn**: 23 clientes n√£o compram h√° 120+ dias e representam R$ 42k em risco

üéØ **A√ß√£o Imediata:**
1. Campanha de reativa√ß√£o SMS/WhatsApp para os 23 clientes inativos (120+ dias) com desconto de 15% v√°lido por 7 dias
2. Criar programa de assinatura mensal com desconto de 8% para os 15 clientes com maior ticket m√©dio
3. Analisar categorias mais compradas e criar bundles espec√≠ficos

‚ö†Ô∏è **Alerta**: 60% da receita concentrada em 12 clientes - implementar a√ß√µes de reten√ß√£o URGENTE para esse grupo."

IMPORTANTE: 
- N√ÉO use termos t√©cnicos como "query", "JSON", "banco de dados"
- N√ÉO seja gen√©rico ou superficial
- N√ÉO sugira apenas "criar estrat√©gia" - DIGA QUAL estrat√©gia
- Sua an√°lise deve AGREGAR VALOR real ao neg√≥cio"""

            response = self.client.chat.completions.create(
                model=settings.OPENAI_MODEL,
                messages=[{"role": "user", "content": prompt}],
                max_tokens=600,  # Aumentado para an√°lises mais profundas
                temperature=0.8  # Aumentado para respostas mais criativas
            )
            
            return response.choices[0].message.content
            
        except Exception as e:
            print(f"‚ö†Ô∏è Erro na convers√£o, usando fallback: {e}")
            
            # Fallback mais rico
            if data and isinstance(data, dict):
                results = data.get("results", [])
                if results and len(results) > 0:
                    first = results[0]
                    
                    # Tentar extrair valor principal
                    main_value = None
                    for key, value in first.items():
                        if isinstance(value, (int, float)) and value > 0:
                            main_value = (key, value)
                            break
                    
                    if main_value:
                        return (
                            f"üìä Encontrei o dado solicitado: **{main_value[0]}** = "
                            f"**R$ {main_value[1]:,.2f}** (total de {metadata.get('row_count', 0)} registros).\n\n"
                            f"üí° Para uma an√°lise mais detalhada, posso explorar outros aspectos desses dados. "
                            f"O que mais gostaria de saber?"
                        )
            
            return "üìä Dados encontrados, mas tive dificuldade em format√°-los. Pode reformular sua pergunta?"
    
    async def _handle_business_chat(
        self,
        user_message: str,
        context_messages: List[Dict[str, str]]
    ) -> str:
        """
        Responde conversa geral sobre NEG√ìCIO (sem consultar banco)
        
        Args:
            user_message: Mensagem do usu√°rio
            context_messages: Contexto
        
        Returns:
            Resposta conversacional
        """
        try:
            messages = [{"role": "system", "content": self.system_prompt}]
            
            # Contexto recente
            messages.extend(context_messages[-4:])
            
            # Mensagem atual
            messages.append({"role": "user", "content": user_message})
            
            response = self.client.chat.completions.create(
                model=settings.OPENAI_MODEL,
                messages=messages,
                max_tokens=300,
                temperature=0.7
            )
            
            return response.choices[0].message.content
            
        except Exception as e:
            print(f"‚ö†Ô∏è Erro na conversa: {e}")
            
            return (
                "Ol√°! üòä Sou seu analista de dados de e-commerce. "
                "Posso ajudar com an√°lises de clientes, receita, margem e clusters. "
                "Pergunte sobre seus dados de neg√≥cio!"
            )
